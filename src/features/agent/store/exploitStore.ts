import { create } from "zustand";
import type { AgentOut, ExploitAgentStep } from "../../../api/agent/types";

export interface ExploitAgentData {
  agentId: string;
  agentSteps: ExploitAgentStep[];
  agentName: string;
}

type FetchPhase = "idle" | "loading" | "success" | "error";

export interface EngagementSlice {
  engagementId?: string;

  agentsById: Record<string, AgentOut>;
  exploitAgentIds: string[];
  stepsByAgentId: Record<string, ExploitAgentStep[]>;
  agentNames: Record<string, string>;

  agentsPhase: FetchPhase;
  stepsPhase: FetchPhase;
  stepsError?: unknown;

  lastAgentsUpdatedAt?: number;
  lastStepsUpdatedAt?: number;

  setEngagementId: (id?: string) => void;
  reset: () => void;

  upsertExploitAgents: (agents: AgentOut[]) => void;
  setAgentsPhase: (p: FetchPhase) => void;

  upsertStepsBatch: (batch: ExploitAgentData[]) => void;
  setStepsPhase: (p: FetchPhase) => void;
  setStepsError: (e: unknown) => void;
}

const initialState: Omit<EngagementSlice,
  "setEngagementId" | "reset" | "upsertExploitAgents" | "setAgentsPhase" | "upsertStepsBatch" | "setStepsPhase" | "setStepsError"
> = {
  engagementId: undefined,
  agentsById: {},
  exploitAgentIds: [],
  stepsByAgentId: {},
  agentNames: {},
  agentsPhase: "idle",
  stepsPhase: "idle",
  stepsError: undefined,
  lastAgentsUpdatedAt: undefined,
  lastStepsUpdatedAt: undefined
};

export const useExploitStore = create<EngagementSlice>((set, get) => ({
  ...initialState,

  setEngagementId: (id?: string) => set({ engagementId: id }),

  reset: () => set({ ...initialState }),

  setAgentsPhase: (p: FetchPhase) => set({ agentsPhase: p }),
  setStepsPhase: (p: FetchPhase) => set({ stepsPhase: p }),
  setStepsError: (e: unknown) => set({ stepsError: e }),

  upsertExploitAgents: (agents: AgentOut[]) =>
    set((s: EngagementSlice) => {
      const nextAgentsById = { ...s.agentsById };
      for (const a of agents) nextAgentsById[a.id] = a;
      const exploitAgentIds = agents
        .filter((a) => a.agent_type === "exploit" && a.agent_status === "running")
        .map((a) => a.id);
      return {
        agentsById: nextAgentsById,
        exploitAgentIds,
        lastAgentsUpdatedAt: Date.now()
      };
    }),

  upsertStepsBatch: (batch: ExploitAgentData[]) =>
    set((s: EngagementSlice) => {
      const stepsByAgentId = { ...s.stepsByAgentId };
      const agentNames = { ...s.agentNames };
      for (const item of batch) {
        stepsByAgentId[item.agentId] = item.agentSteps;
        agentNames[item.agentId] = item.agentName;
      }
      return {
        stepsByAgentId,
        agentNames,
        lastStepsUpdatedAt: Date.now()
      };
    })
}));

export const useExploitSelectors = () => {
  const exploitAgentIds = useExploitStore((s: EngagementSlice) => s.exploitAgentIds);
  const agentsById = useExploitStore((s: EngagementSlice) => s.agentsById);
  const stepsByAgentId = useExploitStore((s: EngagementSlice) => s.stepsByAgentId);
  const agentNames = useExploitStore((s: EngagementSlice) => s.agentNames);
  const agentsPhase = useExploitStore((s: EngagementSlice) => s.agentsPhase);
  const stepsPhase = useExploitStore((s: EngagementSlice) => s.stepsPhase);
  const stepsError = useExploitStore((s: EngagementSlice) => s.stepsError);
  return { exploitAgentIds, agentsById, stepsByAgentId, agentNames, agentsPhase, stepsPhase, stepsError };
};


