import { keepPreviousData, useQuery } from "@tanstack/react-query";
import { agentKeys } from "../queryKeys";
import type { AgentOut, ExploitAgentStep } from "../../../api/agent/types";
import { http } from "../../../api/http";
import { useMockAgentSteps } from "../../mock/useMockAgentSteps";
import { useMockAgents } from "../../mock/useMockAgents";
import { isMockDataEnabled } from "../../../config";

export interface ExploitAgentData {
  agentId: string;
  agentSteps: ExploitAgentStep[];
  agentName: string;
}

export function useExploitAgentIdQuery(
  engagementId?: string,
  options?: {
    findIntervalMs?: number;
    afterFoundIntervalMs?: number;
    keepWatching?: boolean;
    retries?: number;
  }
) {
  const findMs = options?.findIntervalMs ?? 2_000;
  const afterMs = options?.afterFoundIntervalMs ?? 30_000;
  const keepWatching = options?.keepWatching ?? true;
  const retries = options?.retries ?? 2;

  // Check if mock mode is enabled
  const mockEnabled = isMockDataEnabled();

  // Real query implementation - only run when NOT in mock mode
  const realQuery = useQuery<AgentOut[], Error, AgentOut[]>({
    enabled: Boolean(engagementId) && !mockEnabled,
    queryKey: engagementId ? agentKeys.engagementAgents(engagementId) : agentKeys.all,
    queryFn: async ({ signal }) => http.listEngagementAgents(engagementId as string, signal),
    // Dynamic cadence: fast until exploit found, then slow (or stop)
    refetchInterval: (q) => {
      const agents = q.state.data as AgentOut[] | undefined;
      const found = agents?.some((a) => a.agent_type === "exploit" && a.agent_status === "running");
      if (!found) return findMs;
      return keepWatching ? afterMs : false;
    },
    refetchIntervalInBackground: true,
    retry: retries,
    placeholderData: keepPreviousData,
    select: (agents): AgentOut[] => {
      return (agents as AgentOut[]).filter(
        (a) => a.agent_type === "exploit" && (a.agent_status === "running" || a.agent_status === "pending_approval")
      );
    }
  });

  // Use custom mock hook for additive behavior
  const mockAgentsData = useMockAgents();

  if (mockEnabled) {
    return {
      data: mockAgentsData,
      status: "success" as const,
      error: null,
      isLoading: false,
      isSuccess: true,
      isError: false,
      isPending: false,
      isRefetching: false,
      isFetching: false
    };
  }

  return realQuery;
}

export function useExploitAgentStepsQuery(
  exploitAgents?: AgentOut[],
  options?: {
    intervalMs?: number;
    retries?: number;
  }
) {
  const intervalMs = options?.intervalMs ?? 2_000;
  const retries = options?.retries ?? 2;

  // Check if mock mode is enabled
  const mockEnabled = isMockDataEnabled();

  // Real query implementation - only run when NOT in mock mode
  const realQuery = useQuery<ExploitAgentData[], Error, ExploitAgentData[]>({
    enabled: Boolean(exploitAgents?.some(a => a.agent_status === "running")) && !mockEnabled,
    queryKey: exploitAgents?.length ? agentKeys.multipleExploitSteps(exploitAgents.map(a => a.id)) : agentKeys.all,
    queryFn: async ({ signal }): Promise<ExploitAgentData[]> => {
      const runningAgents = (exploitAgents || []).filter(a => a.agent_status === "running");
      if (!runningAgents.length) return [];

      // Fetch steps for all agents concurrently
      const stepPromises = runningAgents.map(async (agent) => {
        try {
          const steps = await http.getAgentSteps(agent.id, signal);
          return {
            agentId: agent.id,
            agentSteps: steps as ExploitAgentStep[],
            agentName: agent.agent_name || agent.id // Fallback to ID if name not available
          } as ExploitAgentData;
        } catch (error) {
          // If one agent fails, still return empty steps for that agent
          console.warn(`Failed to fetch steps for agent ${agent.id}:`, error);
          return {
            agentId: agent.id,
            agentSteps: [],
            agentName: agent.agent_name || agent.id
          } as ExploitAgentData;
        }
      });

      const results = await Promise.allSettled(stepPromises);
      const exploitAgentDataList: ExploitAgentData[] = [];

      results.forEach((result) => {
        if (result.status === 'fulfilled') {
          exploitAgentDataList.push(result.value);
        }
      });

      return exploitAgentDataList;
    },
    refetchInterval: intervalMs,
    refetchIntervalInBackground: true,
    retry: retries,
    placeholderData: keepPreviousData
  });

  // Use custom mock hook for additive behavior
  const mockStepsData = useMockAgentSteps();

  if (mockEnabled) {
    return {
      data: mockStepsData,
      status: "success" as const,
      error: null,
      isLoading: false,
      isSuccess: true,
      isError: false,
      isPending: false,
      isRefetching: false,
      isFetching: false
    };
  }

  return realQuery;
}

export function useExploitAgentSteps(
  engagementId?: string,
  opts?: {
    findIntervalMs?: number;
    afterFoundIntervalMs?: number;
    keepWatchingAgents?: boolean;
    stepsIntervalMs?: number;
  }
) {
  const exploitAgentsQ = useExploitAgentIdQuery(engagementId, {
    findIntervalMs: opts?.findIntervalMs ?? 2000,
    afterFoundIntervalMs: opts?.afterFoundIntervalMs ?? 30000,
    keepWatching: opts?.keepWatchingAgents ?? true
  });

  const stepsQ = useExploitAgentStepsQuery(exploitAgentsQ.data, {
    intervalMs: opts?.stepsIntervalMs ?? 2000
  });

  return {
    exploitAgents: exploitAgentsQ.data, // Now returns array of AgentOut objects
    agentStatus: exploitAgentsQ.status,
    exploitAgentData: stepsQ.data, // Now returns ExploitAgentData[]
    stepsStatus: stepsQ.status,
    stepsError: stepsQ.error
  };
}